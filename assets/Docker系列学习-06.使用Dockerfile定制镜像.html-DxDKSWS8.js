import{_ as c,c as l,a as s,d as a,e as o,f as t,r as d,o as p,b as i}from"./app-BCC5ysrj.js";const r={},u={class:"vuepress-toc"},m={class:"vuepress-toc-item"},k={class:"vuepress-toc-item"},v={class:"vuepress-toc-item"},h={class:"vuepress-toc-item"},b={class:"vuepress-toc-item"},g={class:"vuepress-toc-item"},f={class:"vuepress-toc-item"},D={class:"vuepress-toc-item"},x={class:"vuepress-toc-item"};function R(_,e){const n=d("router-link");return p(),l("div",null,[e[9]||(e[9]=s("h1",{id:"_06-使用dockerfile定制镜像",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_06-使用dockerfile定制镜像"},[s("span",null,"06. 使用Dockerfile定制镜像")])],-1)),s("nav",u,[s("ul",null,[s("li",m,[a(n,{to:"#from指定基础镜像"},{default:o(()=>e[0]||(e[0]=[i("FROM指定基础镜像")])),_:1})]),s("li",k,[a(n,{to:"#run执行命令"},{default:o(()=>e[1]||(e[1]=[i("RUN执行命令")])),_:1})]),s("li",v,[a(n,{to:"#构建镜像"},{default:o(()=>e[2]||(e[2]=[i("构建镜像")])),_:1})]),s("li",h,[a(n,{to:"#镜像构建上下文-context"},{default:o(()=>e[3]||(e[3]=[i("镜像构建上下文(Context)")])),_:1})]),s("li",b,[a(n,{to:"#其他docker-build的用法"},{default:o(()=>e[4]||(e[4]=[i("其他docker build的用法")])),_:1}),s("ul",null,[s("li",g,[a(n,{to:"#直接用-git-repo进行构建"},{default:o(()=>e[5]||(e[5]=[i("直接用 Git repo进行构建")])),_:1})]),s("li",f,[a(n,{to:"#用给定的tar压缩包构建"},{default:o(()=>e[6]||(e[6]=[i("用给定的tar压缩包构建")])),_:1})]),s("li",D,[a(n,{to:"#从标准输入中读取dockerfile进行构建"},{default:o(()=>e[7]||(e[7]=[i("从标准输入中读取Dockerfile进行构建")])),_:1})]),s("li",x,[a(n,{to:"#从标准输入中读取上下文压缩包进行构建"},{default:o(()=>e[8]||(e[8]=[i("从标准输入中读取上下文压缩包进行构建")])),_:1})])])])])]),e[10]||(e[10]=t(`<hr><p><strong>前言</strong> 刚开始使用的是<code>docker commit</code>在定制镜像。<br> 镜像定制实际上就是定制每一层所添加的配置、文件。当我们把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题，镜像构建透明性的问题，体积的问题都会解决，这个脚本就是<code>Dockfile</code><code>Dockerfile</code>是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>以定制<code>nginx</code>镜像为例，我们使用Dockerfile来定制</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment">## 在一个空白目录中，建立一个文本文件，命令为Dockerfile</span></span>
<span class="line"><span class="token function">mkdir</span> mynginx</span>
<span class="line"><span class="token builtin class-name">cd</span> mynginx</span>
<span class="line"><span class="token function">touch</span> Dockerfile</span>
<span class="line">    FROM nginx</span>
<span class="line">    RUN <span class="token builtin class-name">echo</span> <span class="token string">&#39;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&#39;</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html</span>
<span class="line"></span>
<span class="line"><span class="token comment">## 说明：这个Dockerfile很简单，一共两行，涉及两条指令，FROM和RUN</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="from指定基础镜像" tabindex="-1"><a class="header-anchor" href="#from指定基础镜像"><span>FROM指定基础镜像</span></a></h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像之前运行一个nginx镜像的容器，在进行修改，基础镜像是必须指定的。<br> 而<code>FROM</code>：是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p><p>在Docker Hub上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如<code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>php</code>、<code>tomcat</code>等；也有一些方便开发，构建，运行各种语言应用的镜像，如<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>golang</code>等。可以在其中寻找符合最终目标的镜像为基础镜像进行定制</p><p>没有找到对应服务的镜像，官方镜像提供了一些更为基础的操作系统镜像，如<code>ubuntu</code>、<code>centos</code>、<code>debian</code>、<code>fedora</code>、<code>alpine</code>等，这些操作系统的软件库提供了广阔的扩展空间</p><p>除了选择现有镜像为基础镜像外，Docker还存在一个特殊的镜像，为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，表示一个空白的镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">FROM sreatch</span>
<span class="line">···</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>当以scratch为基础镜像的话，意味着不以任何镜像为基础，接下来的所有指令将作为镜像第一层存在。</p><h2 id="run执行命令" tabindex="-1"><a class="header-anchor" href="#run执行命令"><span>RUN执行命令</span></a></h2><p><code>RUN</code>指令是用来执行命令行命令的。由于命令行的能力，<code>RUN</code>指令在定制镜像时时最常用的指令之一。其格式有两种：</p><ul><li>shell格式：<code>RUN &lt;命令&gt;</code>,就像直接在命令行中输入的命令一样。比如：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">RUN <span class="token builtin class-name">echo</span> <span class="token string">&#39;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&#39;</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>exec格式：\`\`RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]，这更像是函数调用中的格式<br> 既然RUN就像shell脚本一样可以执行命令，是否可以向shell脚本一样把每个命令对应一个RUN</li></ul><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line">FROM debian<span class="token punctuation">:</span>stretch</span>
<span class="line"></span>
<span class="line">RUN apt<span class="token punctuation">-</span>get update</span>
<span class="line">RUN apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y gcc libc6<span class="token punctuation">-</span>dev make wget</span>
<span class="line">RUN wget <span class="token punctuation">-</span>O redis.tar.gz &quot;http<span class="token punctuation">:</span>//download.redis.io/releases/redis<span class="token punctuation">-</span>5.0.3.tar.gz&quot;</span>
<span class="line">RUN mkdir <span class="token punctuation">-</span>p /usr/src/redis</span>
<span class="line">RUN tar <span class="token punctuation">-</span>xzf redis.tar.gz <span class="token punctuation">-</span>C /usr/src/redis <span class="token punctuation">-</span><span class="token punctuation">-</span>strip<span class="token punctuation">-</span>components=1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**说明：**由于Dockerfile中每一个指令都会建立一层，<code>RUN</code>也不例外，每一个<code>RUN</code>的行为，就和我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。<br> 上面的写法，创建了5层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em><strong>Union FS是有最大层数限制的，比如AUFS，曾经是最大不超过42层，现在是不得超过127层。</strong></em> 上面的<code>Dockerfile</code>正确的写法：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line">FROM debian<span class="token punctuation">:</span>stretch</span>
<span class="line">RUN buildDeps=&#39;gcc libc6<span class="token punctuation">-</span>dev make wget&#39; \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> apt<span class="token punctuation">-</span>get update \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y $buildDeps \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> wget <span class="token punctuation">-</span>O redis.tar.gz &quot;http<span class="token punctuation">:</span>//download.redis.io/releases/redis<span class="token punctuation">-</span>5.0.3.tar.gz&quot; \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> mkdir <span class="token punctuation">-</span>p /usr/src/redis \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> tar <span class="token punctuation">-</span>xzf redis.tar.gz <span class="token punctuation">-</span>C /usr/src/redis <span class="token punctuation">-</span><span class="token punctuation">-</span>strip<span class="token punctuation">-</span>components=1 \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> make <span class="token punctuation">-</span>C /usr/src/redis \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> make <span class="token punctuation">-</span>C /usr/src/redis install \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/* \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> rm redis.tar.gz \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> rm <span class="token punctuation">-</span>r /usr/src/redis \\</span>
<span class="line">    <span class="token important">&amp;&amp;</span> apt<span class="token punctuation">-</span>get purge <span class="token punctuation">-</span>y <span class="token punctuation">-</span><span class="token punctuation">-</span>auto<span class="token punctuation">-</span>remove $buildDeps</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：<strong>之前的所有命令只有一个目的，就是编译、安装redis可执行文件。所以没有比较建立很多层，只需要在一层中完成。因此，仅仅使用一个RUN指令，并使用&amp;&amp;将各个所需命令串联起来。<br> 并且，这里为了格式化还进行了换行。Dockerfile支持Shell类的行尾添加<code>\\</code>的命令换行方式，以及行首<code>#</code>进行注释的格式。<br> 在这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件、并且清理了<code>apt</code>缓存文件。这是</strong>比较重要</strong>的一步。镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着进项。因此镜像构建上，一定要确保每一层添加需要添加的东西，无关的东西应该清理掉。</p><h2 id="构建镜像" tabindex="-1"><a class="header-anchor" href="#构建镜像"><span>构建镜像</span></a></h2><p>明白了Dockerfile的内容，现在进行构建镜像。<br> 在<code>Dockerfile</code>文件所在目录执行：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> nginx:v2 <span class="token builtin class-name">.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>这里使用 <code>docker build</code>命令进行镜像构建。格式： docker build [选项] &lt;上下文路径/URL/-&gt;</li><li>在这里，指定了最终的镜像名称 -t nginx:v2 构建成功后，可以像之前运行nginx:v2那样来运行这个镜像。</li></ul><h2 id="镜像构建上下文-context" tabindex="-1"><a class="header-anchor" href="#镜像构建上下文-context"><span>镜像构建上下文(Context)</span></a></h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个<code>.</code>。<br> . 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<code>上下文路径</code>。那么什么是上下文呢？</p><p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 <code>Docker 引擎</code>（也就是服务端守护进程）和<code>客户端工具</code>。<code>Docker</code> 的引擎提供了一组 <code>REST AP</code>I，被称为 <code>Docker Remote API</code>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <code>API</code> 与 <code>Docker</code> 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 <code>C/S</code> 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。<br> 当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种<code>客户端/服务端</code>的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <code>Docker 引擎</code>。这样 <code>Docker 引擎</code>收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在<code>dockerfile</code>中这么写：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">COPY ./package.json /app/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>着并不是要复制执行，<code>docker build</code>命令所在的目录下的<code>package.json</code>，也不是复制<code>Dockerfile</code>所在目录下的<code>package.json</code>，而是复制**上下文（context）**目录下的<code>package.json</code><br> 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者<code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去</p><p><strong>理解构建上下文</strong>对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者<strong>项目根目录</strong>下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个<code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br> 那么为什么会有人误以为 <code>.</code>是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code>的文件作为<code>Dockerfile</code>。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h2 id="其他docker-build的用法" tabindex="-1"><a class="header-anchor" href="#其他docker-build的用法"><span>其他<code>docker build</code>的用法</span></a></h2><h3 id="直接用-git-repo进行构建" tabindex="-1"><a class="header-anchor" href="#直接用-git-repo进行构建"><span>直接用 Git repo进行构建</span></a></h3><p><code>docker build</code>还支持从URL构建，比如可以直接从Git repo中构建:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build https://github.com/twang2218/gitlab-ce-zh.git<span class="token comment">#:11.1</span></span>
<span class="line"><span class="token comment"># 这行命令指定了构建所需的Git repo，并且指定默认的master分支，构建目录为/11.1/，然后Docker就会自己去git clone这个项目，切换到指定分支，并进入到指定目录后开始创建</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="用给定的tar压缩包构建" tabindex="-1"><a class="header-anchor" href="#用给定的tar压缩包构建"><span>用给定的tar压缩包构建</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build https://server/context.tar.gz  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果给出的URL不是个git reop，而是个<code>tar</code>压缩包，那么Docker引擎会下载这个包，并自动解压缩，以其作为上下文。开始构建。</p><h3 id="从标准输入中读取dockerfile进行构建" tabindex="-1"><a class="header-anchor" href="#从标准输入中读取dockerfile进行构建"><span>从标准输入中读取Dockerfile进行构建</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build - <span class="token operator">&lt;</span> Dockerfile</span>
<span class="line"><span class="token comment"># 或者</span></span>
<span class="line"><span class="token function">cat</span> Dockerfile <span class="token operator">|</span> <span class="token function">docker</span> build -</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，他没有上下文。因此不可能像其他方法那样可以将本地文件<code>COPY</code>进镜像之类的事情。。</p><h3 id="从标准输入中读取上下文压缩包进行构建" tabindex="-1"><a class="header-anchor" href="#从标准输入中读取上下文压缩包进行构建"><span>从标准输入中读取上下文压缩包进行构建</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build - <span class="token operator">&lt;</span> context.tar.gz</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当发现标准输入的文件格式是：<code>gzip</code>、<code>bzip2</code>、以及<code>xz</code>的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>`,49))])}const U=c(r,[["render",R],["__file","Docker系列学习-06.使用Dockerfile定制镜像.html.vue"]]),y=JSON.parse('{"path":"/flinux/Kubernetes/Docker%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/Docker%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-06.%E4%BD%BF%E7%94%A8Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F.html","title":"06. 使用Dockerfile定制镜像","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"FROM指定基础镜像","slug":"from指定基础镜像","link":"#from指定基础镜像","children":[]},{"level":2,"title":"RUN执行命令","slug":"run执行命令","link":"#run执行命令","children":[]},{"level":2,"title":"构建镜像","slug":"构建镜像","link":"#构建镜像","children":[]},{"level":2,"title":"镜像构建上下文(Context)","slug":"镜像构建上下文-context","link":"#镜像构建上下文-context","children":[]},{"level":2,"title":"其他docker build的用法","slug":"其他docker-build的用法","link":"#其他docker-build的用法","children":[{"level":3,"title":"直接用 Git repo进行构建","slug":"直接用-git-repo进行构建","link":"#直接用-git-repo进行构建","children":[]},{"level":3,"title":"用给定的tar压缩包构建","slug":"用给定的tar压缩包构建","link":"#用给定的tar压缩包构建","children":[]},{"level":3,"title":"从标准输入中读取Dockerfile进行构建","slug":"从标准输入中读取dockerfile进行构建","link":"#从标准输入中读取dockerfile进行构建","children":[]},{"level":3,"title":"从标准输入中读取上下文压缩包进行构建","slug":"从标准输入中读取上下文压缩包进行构建","link":"#从标准输入中读取上下文压缩包进行构建","children":[]}]}],"git":{"updatedTime":1709276200000,"contributors":[{"name":"Linkefou","username":"Linkefou","email":"wlh724567296@163.com","commits":1},{"name":"wanglinhao","username":"wanglinhao","email":"wanglinhao@wegooooo.com","commits":2}]},"filePathRelative":"flinux/Kubernetes/Docker系列学习/Docker系列学习-06.使用Dockerfile定制镜像.md"}');export{U as comp,y as data};
