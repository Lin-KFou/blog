import{_ as i,c as o,a as n,d as a,e as l,f as r,r as p,o as c,b as t}from"./app-BCC5ysrj.js";const d={},u={class:"vuepress-toc"},m={class:"vuepress-toc-item"},g={class:"vuepress-toc-item"},v={class:"vuepress-toc-item"},h={class:"vuepress-toc-item"},k={class:"vuepress-toc-item"},b={class:"vuepress-toc-item"},_={class:"vuepress-toc-item"},f={class:"vuepress-toc-item"},D={class:"vuepress-toc-item"},E={class:"vuepress-toc-item"},x={class:"vuepress-toc-item"},q={class:"vuepress-toc-item"},O={class:"vuepress-toc-item"};function y(N,s){const e=p("router-link");return c(),o("div",null,[s[13]||(s[13]=n("h1",{id:"_07-dockerfile指令详解",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_07-dockerfile指令详解"},[n("span",null,"07. Dockerfile指令详解")])],-1)),n("nav",u,[n("ul",null,[n("li",m,[a(e,{to:"#简介"},{default:l(()=>s[0]||(s[0]=[t("简介")])),_:1})]),n("li",g,[a(e,{to:"#_1-文件操作指令"},{default:l(()=>s[1]||(s[1]=[t("1. 文件操作指令")])),_:1}),n("ul",null,[n("li",v,[a(e,{to:"#_1-1-copy-复制文件"},{default:l(()=>s[2]||(s[2]=[t("1.1 COPY 复制文件")])),_:1})]),n("li",h,[a(e,{to:"#_1-2-add-高级复制文件"},{default:l(()=>s[3]||(s[3]=[t("1.2 ADD 高级复制文件")])),_:1})])])]),n("li",k,[a(e,{to:"#_2-容器运行指令"},{default:l(()=>s[4]||(s[4]=[t("2. 容器运行指令")])),_:1}),n("ul",null,[n("li",b,[a(e,{to:"#_2-1-cmd-容器启动命令"},{default:l(()=>s[5]||(s[5]=[t("2.1 CMD 容器启动命令")])),_:1})]),n("li",_,[a(e,{to:"#_2-2-entrypoint-入口点"},{default:l(()=>s[6]||(s[6]=[t("2.2 ENTRYPOINT 入口点")])),_:1})]),n("li",f,[a(e,{to:"#_2-3-env-设置环境变量"},{default:l(()=>s[7]||(s[7]=[t("2.3 ENV 设置环境变量")])),_:1})]),n("li",D,[a(e,{to:"#_2-4-volume-定义匿名卷"},{default:l(()=>s[8]||(s[8]=[t("2.4 VOLUME 定义匿名卷")])),_:1})]),n("li",E,[a(e,{to:"#_2-5-expose-声明端口"},{default:l(()=>s[9]||(s[9]=[t("2.5 EXPOSE 声明端口")])),_:1})]),n("li",x,[a(e,{to:"#_2-6-workdir-指定工作目录"},{default:l(()=>s[10]||(s[10]=[t("2.6 WORKDIR 指定工作目录")])),_:1})]),n("li",q,[a(e,{to:"#_2-7-user指定当前用户"},{default:l(()=>s[11]||(s[11]=[t("2.7 USER指定当前用户")])),_:1})]),n("li",O,[a(e,{to:"#_2-8-healthcheck-健康检查"},{default:l(()=>s[12]||(s[12]=[t("2.8 HEALTHCHECK 健康检查")])),_:1})])])])])]),s[14]||(s[14]=r(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>Dockerfile 是用于构建 Docker 镜像的文本文件，它包含了一系列的指令和参数。本文将详细介绍常用的 Dockerfile 指令，包括 <code>FROM</code>、<code>RUN</code>、<code>COPY</code>、<code>ADD</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ENV</code> 等。</p><h2 id="_1-文件操作指令" tabindex="-1"><a class="header-anchor" href="#_1-文件操作指令"><span>1. 文件操作指令</span></a></h2><h3 id="_1-1-copy-复制文件" tabindex="-1"><a class="header-anchor" href="#_1-1-copy-复制文件"><span>1.1 COPY 复制文件</span></a></h3><p><strong>格式</strong>：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;]&lt;源路径&gt;...&lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;][&quot;&lt;源路径&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;]</code></li></ul><p><code>COPY</code> 指令将从构建上下文目录中的源路径复制文件/目录到镜像内的目标路径。支持两种格式：命令行格式和函数调用格式。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">COPY package.json /usr/src/app/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>源路径特性：</strong></p><ul><li>支持多个源路径</li><li>支持通配符（遵循 Go 的 filepath.Match 规则）</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">COPY hom* /mydir/</span>
<span class="line">COPY hom?.txt /mydir/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>目标路径说明：</strong></p><ul><li>支持绝对路径和相对路径（相对于 WORKDIR）</li><li>目录会自动创建</li><li>保留源文件的元数据（权限、时间戳等）</li></ul><p><strong>权限设置：</strong> 可以使用 <code>--chown</code> 选项设置文件的所属用户和组：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">COPY --chown=55:mygroup files* /mydir/</span>
<span class="line">COPY --chown=bin files* /mydir/</span>
<span class="line">COPY --choen=1 files* /mydir/</span>
<span class="line">COPY --chown=10:11 files* /mydir/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-add-高级复制文件" tabindex="-1"><a class="header-anchor" href="#_1-2-add-高级复制文件"><span>1.2 ADD 高级复制文件</span></a></h3><p><code>ADD</code> 指令是 <code>COPY</code> 的增强版本，提供了更多功能：</p><p><strong>URL 支持：</strong></p><ul><li>支持从 URL 下载文件</li><li>下载文件权限默认为 600</li><li>不推荐使用此功能，建议使用 RUN + wget/curl</li></ul><p><strong>自动解压：</strong></p><ul><li>支持 tar、gzip、bzip2、xz 格式</li><li>自动解压到目标路径</li></ul><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">FROM scratch</span>
<span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意：</strong> 如果只想复制压缩文件而不解压，应使用 <code>COPY</code> 指令</p></blockquote><p><strong>最佳实践：</strong></p><ul><li>优先使用 <code>COPY</code>（功能单一，行为明确）</li><li>仅在需要自动解压缩时使用 <code>ADD</code></li></ul><blockquote><p><strong>警告：</strong> <code>ADD</code> 指令会使构建缓存失效，可能降低构建速度</p></blockquote><p><strong>权限设置：</strong> 同样支持 <code>--chown</code> 选项：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">ADD --chown=55:mygroup files* /mydir/</span>
<span class="line">ADD --chown=bin files* /mydir/</span>
<span class="line">ADD --chown=1 files* /mydir/</span>
<span class="line">ADD --chown=10:11 files* /mydir/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-容器运行指令" tabindex="-1"><a class="header-anchor" href="#_2-容器运行指令"><span>2. 容器运行指令</span></a></h2><h3 id="_2-1-cmd-容器启动命令" tabindex="-1"><a class="header-anchor" href="#_2-1-cmd-容器启动命令"><span>2.1 CMD 容器启动命令</span></a></h3><p><strong>格式：</strong></p><ul><li>shell 格式：<code>CMD &lt;命令&gt;</code></li><li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul><p><strong>作用：</strong></p><ul><li>指定容器启动时的默认命令</li><li>可以被 docker run 命令行参数覆盖</li><li>每个 Dockerfile 只能有一个 CMD</li></ul><p><strong>使用示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 默认命令</span></span>
<span class="line">CMD <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span>, <span class="token string">&quot;-g&quot;</span>, <span class="token string">&quot;daemon off;&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 带参数的 ENTRYPOINT</span></span>
<span class="line">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span><span class="token punctuation">]</span></span>
<span class="line">CMD <span class="token punctuation">[</span><span class="token string">&quot;-g&quot;</span>, <span class="token string">&quot;daemon off;&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>最佳实践：</strong></p><ul><li>使用 exec 格式 ([&quot;command&quot;, &quot;param1&quot;, &quot;param2&quot;])</li><li>避免使用 shell 格式 (command param1 param2)</li><li>确保应用程序在前台运行</li></ul><blockquote><p><strong>注意：</strong> Docker 容器中的应用应该以前台方式运行，而不是作为后台服务</p></blockquote><h3 id="_2-2-entrypoint-入口点" tabindex="-1"><a class="header-anchor" href="#_2-2-entrypoint-入口点"><span>2.2 ENTRYPOINT 入口点</span></a></h3><p><strong>格式：</strong></p><ul><li>exec 格式：<code>ENTRYPOINT [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li><li>shell 格式：<code>ENTRYPOINT command param1 param2</code></li></ul><p><strong>作用：</strong></p><ul><li>配置容器启动时运行的命令</li><li>不会被 docker run 的命令行参数覆盖</li><li>可以接收 CMD 指令或运行参数</li></ul><p><strong>使用场景：</strong></p><ul><li>需要固定的启动命令</li><li>需要处理命令行参数</li><li>作为可执行程序使用</li></ul><p><strong>示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 固定的入口点</span></span>
<span class="line">ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 可以在运行时添加参数</span></span>
<span class="line"><span class="token function">docker</span> run myimage <span class="token parameter variable">-g</span> <span class="token string">&quot;daemon off;&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-env-设置环境变量" tabindex="-1"><a class="header-anchor" href="#_2-3-env-设置环境变量"><span>2.3 ENV 设置环境变量</span></a></h3><p><strong>格式：</strong></p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p><strong>作用：</strong></p><ul><li>设置环境变量</li><li>可被后续指令使用</li><li>在容器运行时仍然有效</li></ul><p><strong>示例：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">ENV VERSION=1.0 DEBUG=on \\</span>
<span class="line">    NAME=&quot;Happy Feet&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>支持的指令：</strong> ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD</p><p><strong>最佳实践：</strong></p><ul><li>使用环境变量增加构建灵活性</li><li>一个 Dockerfile 可通过不同环境变量构建不同镜像</li></ul><h3 id="_2-4-volume-定义匿名卷" tabindex="-1"><a class="header-anchor" href="#_2-4-volume-定义匿名卷"><span>2.4 VOLUME 定义匿名卷</span></a></h3><p><strong>格式：</strong></p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p><strong>作用：</strong></p><ul><li>声明容器数据持久化目录</li><li>避免向容器存储层写入数据</li><li>运行时可被显式挂载覆盖</li></ul><p><strong>示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 声明匿名卷</span></span>
<span class="line">VOLUME /data</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 运行时覆盖匿名卷</span></span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> mydata:/data image_name</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-expose-声明端口" tabindex="-1"><a class="header-anchor" href="#_2-5-expose-声明端口"><span>2.5 EXPOSE 声明端口</span></a></h3><p><strong>格式：</strong></p><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p><p><strong>作用：</strong></p><ul><li>声明容器对外提供的服务端口</li><li>帮助镜像使用者理解端口用途</li><li>配合 docker run -P 实现随机端口映射</li></ul><blockquote><p><strong>注意：</strong> EXPOSE 仅作为文档说明使用，不会自动开启端口，需要 -p 参数映射端口</p></blockquote><h3 id="_2-6-workdir-指定工作目录" tabindex="-1"><a class="header-anchor" href="#_2-6-workdir-指定工作目录"><span>2.6 WORKDIR 指定工作目录</span></a></h3><p><strong>格式：</strong></p><p><code>WORKDIR &lt;工作目录路径&gt;</code></p><p><strong>作用：</strong></p><ul><li>设置工作目录</li><li>影响后续指令的工作路径</li><li>不存在的目录会被自动创建</li></ul><p><strong>最佳实践：</strong></p><ul><li>使用绝对路径</li><li>避免使用 RUN cd 命令</li><li>每个 RUN 指令都在独立的容器中执行</li></ul><h3 id="_2-7-user指定当前用户" tabindex="-1"><a class="header-anchor" href="#_2-7-user指定当前用户"><span>2.7 USER指定当前用户</span></a></h3><p><strong>格式：</strong></p><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><strong>作用：</strong></p><ul><li>指定后续命令的执行用户</li><li>影响 RUN、CMD 和 ENTRYPOINT 指令</li><li>用户必须预先创建</li></ul><p><strong>示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">RUN <span class="token function">groupadd</span> <span class="token parameter variable">-r</span> redis <span class="token operator">&amp;&amp;</span> <span class="token function">useradd</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-g</span> redis redis </span>
<span class="line"><span class="token environment constant">USER</span> redis</span>
<span class="line">RUN <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>最佳实践：</strong></p><ul><li>避免使用 root 用户运行应用</li><li>使用 gosu 代替 su/sudo 切换用户</li><li>在构建阶段创建所需用户</li></ul><p><strong>使用 gosu 示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 建立redis用户，并使用gosu换另一个用户执行命令</span></span>
<span class="line">RUN <span class="token function">groupadd</span> <span class="token parameter variable">-r</span> redis <span class="token operator">&amp;&amp;</span> <span class="token function">useradd</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-g</span> redis redis</span>
<span class="line"><span class="token comment"># 下载gosu</span></span>
<span class="line">RUN <span class="token function">wget</span> <span class="token parameter variable">-O</span> /usr/local/bin/gosu <span class="token string">&quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</span> <span class="token punctuation">\\</span></span>
<span class="line">    <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +X /usr/local/bin/gosu <span class="token punctuation">\\</span></span>
<span class="line">    <span class="token variable">$$</span> gosu nobody <span class="token boolean">true</span></span>
<span class="line"><span class="token comment"># 设置CMD，并以另外的用户执行</span></span>
<span class="line">CMD <span class="token punctuation">[</span><span class="token string">&quot;exec&quot;</span>,<span class="token string">&quot;gosu&quot;</span>,<span class="token string">&quot;redis&quot;</span>,<span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-8-healthcheck-健康检查" tabindex="-1"><a class="header-anchor" href="#_2-8-healthcheck-健康检查"><span>2.8 HEALTHCHECK 健康检查</span></a></h3><p><strong>格式：</strong></p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>: 设置检查容器健康状态的命令</li><li><code>HEALTHCHECK NONE</code>: 禁用基础镜像中的健康检查指令</li></ul><p><strong>作用：</strong></p><ul><li>定期检查容器服务状态</li><li>发现服务异常（如死锁、死循环）</li><li>支持容器自动调度和故障转移</li></ul><p><strong>状态变化：</strong></p><ul><li><code>starting</code>: 初始状态</li><li><code>healthy</code>: 检查成功</li><li><code>unhealthy</code>: 连续检查失败</li></ul><p><strong>支持的选项：</strong></p><ul><li>--interval=&lt;间隔&gt; : 两次健康检查的间隔，默认为30秒</li><li>--timeout=&lt;时长&gt; : 康检查命令运行超时时间，如果超过这个时间，本次健康检查被视为失败，默认30秒</li><li>--retries=&lt;次数&gt; : 当连续时报指定次数后，则将容器状态视为unhealthy,默认3次</li></ul><p><strong>返回值：</strong></p><ul><li><code>0</code>: 检查成功</li><li><code>1</code>: 检查失败</li><li><code>2</code>: 保留值，不要使用</li></ul><h4 id="示例-检查-web-服务" tabindex="-1"><a class="header-anchor" href="#示例-检查-web-服务"><span>示例：检查 Web 服务</span></a></h4><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre><code><span class="line"><span class="token comment"># Dockerfile</span></span>
<span class="line">FROM nginx</span>
<span class="line">RUN apt<span class="token punctuation">-</span>get update <span class="token important">&amp;&amp;</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl <span class="token important">&amp;&amp;</span> rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*</span>
<span class="line">HEALTHCHECK <span class="token punctuation">-</span><span class="token punctuation">-</span>interval=5s  <span class="token punctuation">-</span><span class="token punctuation">-</span>timeout=3s \\</span>
<span class="line">CMD curl <span class="token punctuation">-</span>fs http<span class="token punctuation">:</span>//localhost/ <span class="token punctuation">|</span><span class="token punctuation">|</span> exit 1</span>
<span class="line"><span class="token comment"># 说明：这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>运行示例：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> build <span class="token parameter variable">-t</span> myweb:v1 <span class="token builtin class-name">.</span>  <span class="token comment">#构建镜像</span></span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> web <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 myweb:v1  <span class="token comment">#启动容器</span></span>
<span class="line"><span class="token function">docker</span> container <span class="token function">ls</span>         <span class="token comment">#查看容器状态</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查看健康状态：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> inspect <span class="token parameter variable">--format</span> <span class="token string">&#39;{{json .State.Health}}&#39;</span> web <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p><strong>参考文档：</strong><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener noreferrer">Dockerfile官当文档</a><br><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener noreferrer">Dockerfile实践文档</a><br><a href="https://github.com/docker-library/docs" target="_blank" rel="noopener noreferrer">Docker官方镜像</a></p></blockquote>`,108))])}const R=i(d,[["render",y],["__file","Docker系列学习-07.Dockerfile指令详解.html.vue"]]),P=JSON.parse('{"path":"/flinux/Kubernetes/Docker%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/Docker%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-07.Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","title":"07. Dockerfile指令详解","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"1. 文件操作指令","slug":"_1-文件操作指令","link":"#_1-文件操作指令","children":[{"level":3,"title":"1.1 COPY 复制文件","slug":"_1-1-copy-复制文件","link":"#_1-1-copy-复制文件","children":[]},{"level":3,"title":"1.2 ADD 高级复制文件","slug":"_1-2-add-高级复制文件","link":"#_1-2-add-高级复制文件","children":[]}]},{"level":2,"title":"2. 容器运行指令","slug":"_2-容器运行指令","link":"#_2-容器运行指令","children":[{"level":3,"title":"2.1 CMD 容器启动命令","slug":"_2-1-cmd-容器启动命令","link":"#_2-1-cmd-容器启动命令","children":[]},{"level":3,"title":"2.2 ENTRYPOINT 入口点","slug":"_2-2-entrypoint-入口点","link":"#_2-2-entrypoint-入口点","children":[]},{"level":3,"title":"2.3 ENV 设置环境变量","slug":"_2-3-env-设置环境变量","link":"#_2-3-env-设置环境变量","children":[]},{"level":3,"title":"2.4 VOLUME 定义匿名卷","slug":"_2-4-volume-定义匿名卷","link":"#_2-4-volume-定义匿名卷","children":[]},{"level":3,"title":"2.5 EXPOSE 声明端口","slug":"_2-5-expose-声明端口","link":"#_2-5-expose-声明端口","children":[]},{"level":3,"title":"2.6 WORKDIR 指定工作目录","slug":"_2-6-workdir-指定工作目录","link":"#_2-6-workdir-指定工作目录","children":[]},{"level":3,"title":"2.7 USER指定当前用户","slug":"_2-7-user指定当前用户","link":"#_2-7-user指定当前用户","children":[]},{"level":3,"title":"2.8 HEALTHCHECK 健康检查","slug":"_2-8-healthcheck-健康检查","link":"#_2-8-healthcheck-健康检查","children":[]}]}],"git":{"updatedTime":1709276200000,"contributors":[{"name":"Linkefou","username":"Linkefou","email":"wlh724567296@163.com","commits":1},{"name":"wanglinhao","username":"wanglinhao","email":"wanglinhao@wegooooo.com","commits":2}]},"filePathRelative":"flinux/Kubernetes/Docker系列学习/Docker系列学习-07.Dockerfile指令详解.md"}');export{R as comp,P as data};
